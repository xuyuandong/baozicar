/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef order_TYPES_H
#define order_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace scheduler {

class Path;

class Order;

class Driver;

class HistoryDriver;

class PoolOrder;

class Message;

typedef struct _Path__isset {
  _Path__isset() : from_city(false), from_place(false), to_city(false), to_place(false) {}
  bool from_city :1;
  bool from_place :1;
  bool to_city :1;
  bool to_place :1;
} _Path__isset;

class Path {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  Path(const Path&);
  Path& operator=(const Path&);
  Path() : from_city(), from_place(), to_city(), to_place() {
  }

  virtual ~Path() throw();
  std::string from_city;
  std::string from_place;
  std::string to_city;
  std::string to_place;

  _Path__isset __isset;

  void __set_from_city(const std::string& val);

  void __set_from_place(const std::string& val);

  void __set_to_city(const std::string& val);

  void __set_to_place(const std::string& val);

  bool operator == (const Path & rhs) const
  {
    if (!(from_city == rhs.from_city))
      return false;
    if (!(from_place == rhs.from_place))
      return false;
    if (!(to_city == rhs.to_city))
      return false;
    if (!(to_place == rhs.to_place))
      return false;
    return true;
  }
  bool operator != (const Path &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Path & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Path& obj);
};

void swap(Path &a, Path &b);

typedef struct _Order__isset {
  _Order__isset() : id(false), path(false), phone(false), number(false), cartype(false), price(false) {}
  bool id :1;
  bool path :1;
  bool phone :1;
  bool number :1;
  bool cartype :1;
  bool price :1;
} _Order__isset;

class Order {
 public:

  static const char* ascii_fingerprint; // = "1DDFF9AA71DC5E60FC7110599F2C2CA9";
  static const uint8_t binary_fingerprint[16]; // = {0x1D,0xDF,0xF9,0xAA,0x71,0xDC,0x5E,0x60,0xFC,0x71,0x10,0x59,0x9F,0x2C,0x2C,0xA9};

  Order(const Order&);
  Order& operator=(const Order&);
  Order() : id(0), phone(), number(0), cartype(0), price(0) {
  }

  virtual ~Order() throw();
  int64_t id;
  Path path;
  std::string phone;
  int32_t number;
  int32_t cartype;
  int32_t price;

  _Order__isset __isset;

  void __set_id(const int64_t val);

  void __set_path(const Path& val);

  void __set_phone(const std::string& val);

  void __set_number(const int32_t val);

  void __set_cartype(const int32_t val);

  void __set_price(const int32_t val);

  bool operator == (const Order & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(phone == rhs.phone))
      return false;
    if (!(number == rhs.number))
      return false;
    if (!(cartype == rhs.cartype))
      return false;
    if (!(price == rhs.price))
      return false;
    return true;
  }
  bool operator != (const Order &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Order & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Order& obj);
};

void swap(Order &a, Order &b);

typedef struct _Driver__isset {
  _Driver__isset() : phone(false), priority(false) {}
  bool phone :1;
  bool priority :1;
} _Driver__isset;

class Driver {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  Driver(const Driver&);
  Driver& operator=(const Driver&);
  Driver() : phone(), priority(0) {
  }

  virtual ~Driver() throw();
  std::string phone;
  int32_t priority;

  _Driver__isset __isset;

  void __set_phone(const std::string& val);

  void __set_priority(const int32_t val);

  bool operator == (const Driver & rhs) const
  {
    if (!(phone == rhs.phone))
      return false;
    if (!(priority == rhs.priority))
      return false;
    return true;
  }
  bool operator != (const Driver &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Driver & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Driver& obj);
};

void swap(Driver &a, Driver &b);

typedef struct _HistoryDriver__isset {
  _HistoryDriver__isset() : drivers(false) {}
  bool drivers :1;
} _HistoryDriver__isset;

class HistoryDriver {
 public:

  static const char* ascii_fingerprint; // = "CE3B5B4FE5AAD4082A2B721F0B604B21";
  static const uint8_t binary_fingerprint[16]; // = {0xCE,0x3B,0x5B,0x4F,0xE5,0xAA,0xD4,0x08,0x2A,0x2B,0x72,0x1F,0x0B,0x60,0x4B,0x21};

  HistoryDriver(const HistoryDriver&);
  HistoryDriver& operator=(const HistoryDriver&);
  HistoryDriver() {
  }

  virtual ~HistoryDriver() throw();
  std::set<std::string>  drivers;

  _HistoryDriver__isset __isset;

  void __set_drivers(const std::set<std::string> & val);

  bool operator == (const HistoryDriver & rhs) const
  {
    if (!(drivers == rhs.drivers))
      return false;
    return true;
  }
  bool operator != (const HistoryDriver &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HistoryDriver & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HistoryDriver& obj);
};

void swap(HistoryDriver &a, HistoryDriver &b);

typedef struct _PoolOrder__isset {
  _PoolOrder__isset() : id(false), cartype(false), order_list(false), pushtime(false), drivers(false) {}
  bool id :1;
  bool cartype :1;
  bool order_list :1;
  bool pushtime :1;
  bool drivers :1;
} _PoolOrder__isset;

class PoolOrder {
 public:

  static const char* ascii_fingerprint; // = "B3E6BEB38EF357D523067C94BF6A39EF";
  static const uint8_t binary_fingerprint[16]; // = {0xB3,0xE6,0xBE,0xB3,0x8E,0xF3,0x57,0xD5,0x23,0x06,0x7C,0x94,0xBF,0x6A,0x39,0xEF};

  PoolOrder(const PoolOrder&);
  PoolOrder& operator=(const PoolOrder&);
  PoolOrder() : id(), cartype(0), pushtime(0) {
  }

  virtual ~PoolOrder() throw();
  std::string id;
  int32_t cartype;
  std::vector<Order>  order_list;
  int64_t pushtime;
  std::vector<std::string>  drivers;

  _PoolOrder__isset __isset;

  void __set_id(const std::string& val);

  void __set_cartype(const int32_t val);

  void __set_order_list(const std::vector<Order> & val);

  void __set_pushtime(const int64_t val);

  void __set_drivers(const std::vector<std::string> & val);

  bool operator == (const PoolOrder & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(cartype == rhs.cartype))
      return false;
    if (!(order_list == rhs.order_list))
      return false;
    if (!(pushtime == rhs.pushtime))
      return false;
    if (!(drivers == rhs.drivers))
      return false;
    return true;
  }
  bool operator != (const PoolOrder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PoolOrder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PoolOrder& obj);
};

void swap(PoolOrder &a, PoolOrder &b);

typedef struct _Message__isset {
  _Message__isset() : template_type(false), push_type(false), app_type(false), title(false), content(false), text(false), url(false), target(false) {}
  bool template_type :1;
  bool push_type :1;
  bool app_type :1;
  bool title :1;
  bool content :1;
  bool text :1;
  bool url :1;
  bool target :1;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "DE77150680E85FCEF44D37C23EABCA98";
  static const uint8_t binary_fingerprint[16]; // = {0xDE,0x77,0x15,0x06,0x80,0xE8,0x5F,0xCE,0xF4,0x4D,0x37,0xC2,0x3E,0xAB,0xCA,0x98};

  Message(const Message&);
  Message& operator=(const Message&);
  Message() : template_type(0), push_type(0), app_type(0), title(), content(), text(), url() {
  }

  virtual ~Message() throw();
  int32_t template_type;
  int32_t push_type;
  int32_t app_type;
  std::string title;
  std::string content;
  std::string text;
  std::string url;
  std::vector<std::string>  target;

  _Message__isset __isset;

  void __set_template_type(const int32_t val);

  void __set_push_type(const int32_t val);

  void __set_app_type(const int32_t val);

  void __set_title(const std::string& val);

  void __set_content(const std::string& val);

  void __set_text(const std::string& val);

  void __set_url(const std::string& val);

  void __set_target(const std::vector<std::string> & val);

  bool operator == (const Message & rhs) const
  {
    if (!(template_type == rhs.template_type))
      return false;
    if (!(push_type == rhs.push_type))
      return false;
    if (!(app_type == rhs.app_type))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(content == rhs.content))
      return false;
    if (!(text == rhs.text))
      return false;
    if (!(url == rhs.url))
      return false;
    if (!(target == rhs.target))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Message& obj);
};

void swap(Message &a, Message &b);

} // namespace

#endif
